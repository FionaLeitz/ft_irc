Créez votre propre serveur IRC, en suivant les RFC standards d'Internet.
L’objectif de ce projet est de reproduire le fonctionnement d’un serveur IRC.
Vous utiliserez un vrai client IRC afin de vous connecter à votre serveur et ainsi de le
tester.
Internet fonctionne grâce à de nombreux standards et protocoles pour permettre une
interopérabilité entre les machines connectées. Il est toujours intéressant de connaître ce
genre de chose.


Si on veut utiliser le client hexchat (pour ne pas prendre irci et etre que en ligne de commande),
on peut facilement l'installer avec :

apt-get download hexchat
dpkg -x "nom du fichier telecharge" .
mv usr/bin/hexchat hexchat

Et bim ! On peut executer ./hexchat


Qu'est ce qu'une socket ? Deja apparemment on dit UN socket.
-un connecteur reseau, ou interface de connection
-genre d'intermediaire a la connection, qui va gerer des problematique de reseau pour nous



Fonctions autorisees :


socket:
<sys/socket.h>
int	socket( int domain, int type, int protocol );
 - create an unbound socket in a communications domain, and return a file descriptor that can be used
  in later function calls that operate on sockets.
		* domain : specifies the communications domain in which a socket is to be created
		* type : specifies the type of socket to be created
		* protocol : specifies a particular protocol to be used with the socket (protocol of 0 for
			an unspecified default protocol appropriate for the type)

Dans la routine socket (int domaine, int type, int protocole), le paramètre "domaine" précise si le socket
est pour une communication réseau ou une communication inter-processus;
si on est dans le premier cas,  on parle de socket internet et le paramètre domaine prend la valeur "AF_INET".
Si c'est le deuxième  cas, on a un socket UNIX c'est à dire une communication inter-processus et le paramètre "domaine" vaut AF_UNIX;
toutefois, quelque soit le domaine choisi, on se retrouve dans l'un des quatre modes de communication suivantes:

    1. en mode connecté à travers Internet : TCP
    2. en mode connecté à travers Unix : TCP
    3. en mode datagramme à travers Internet : UDP
    4. en mode datagramme à travers Unix : UDP

Dans le cadre de l'implémentation d'un serveur IRC en C++, les sockets sont utilisés pour permettre aux clients (utilisateurs du serveur)
de se connecter et de communiquer avec le serveur. 


close:
<unistd.h>
int	close( int filedes );
 -close un fd

setsockopt:
<sys/socket.h>
int	setsockopt( int sockfd, int level, int optname, const void *optval, socklen_t optlen );
 -

struct sockaddr {
	ushort	sa_family;						---> address family
	char	sa_data[14];					---> socket address (je crois que sa taille est variable ?)
}

getsockname:
<sys/socket.h>
int	getsockname( int socket, struct sockaddr *name, int *namelen );
 -stock des information sur le socket dans le pointeur name.
		* socket : le socket descriptor
		* name : l'adresse du buffer ou stocker les infos sur le socket
		* namelen : pointe vers un entier contenant la taille en bytes de name, puis est rempli par la taille requise.

struct protoent {
	char	*p_name;						---> official protocol name
	char	**p_aliases;					---> alias list
	int		p_proto;						---> protocol number
}

getprotobyname:
<netdb.h>
struct protoent	*getprotobyname( const char *name );
 -retourne une structure protoent pour l'entree depuis la database qui correspond au nom du protocole donne.

struct hostent {
	char	*h_name;						---> official name of host
	char	**h_aliases;					---> alias list
	int		h_addrtype;						---> host address type
	int		h_length;						---> length of address
	char	**h_addr_list;					---> list of addresses
}

gethostbyname:
<netdb.h>
struct hostent	*gethostbyname( const char *name );
 -retourne une structure hostent correspondant au name (hostname ou adresse IPv4).

struct addrinfo {
	int					ai_flags;
	int					ai_family;
	int					ai_socktype;
	int					ai_protocol;
	socklen_t			ai_addrlen;
	struct sockaddr		*ai_addr;
	char				*ai_canonname;
	struct addrinfo		*ai_next;
}

getaddrinfo:
<netdb.h>
int	getaddrinfo( const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res );
  -retourne une ou plusieurs structure addrinfo, contenant une adresse Internet qui peut etre utilisee dans un appel a bind() ou connect().
		*

freeaddrinfo:


bind:
#include <sys/types.h>
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	- FOURNIR UN NOM A UNE SOCKET

	args :
		1. int sockfd : fd de la socket
		2. const struct sockaddr *addr : addresse a affecter a la socket
		3. socklen_t addrlen : taille de en octet de la structure d'adresse 

	Traditionnellement cette opération est appelée « affectation d'un nom à une socket ».
	Après sa création, une socket n’est connue que du processus qui l’a créée et par ses descendants. Elle doit être désignée par une adresse
	pour pouvoir être contactée de l’extérieur par d'autres processus locaux ou distants.
	bind() affecte l'adresse spécifiée dans addr à la socket référencée par le descripteur de fichier sockfd.

	retour : Renvoie 0 si il réussit.
			 Renvoie -1 en cas d'échec, auquel cas errno est renseignée en conséquence.  


connect:
#include <sys/types.h>
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);
	- DEBUTER UNE CONNEXION SUR UNE SOCKET

	args :
		1. int sockfd : fd de la socket
		2. const struct sockaddr *serv_addr : adresse a laquelle connecter la socket (si la socket est du type SOCK_STREAM ou SOCK_SEQPACKET,
											  cette fonction tente de se connecter à la socket qui est liée à l'adresse indiquée par serv_addr)
		3. socklen_t addrlen : taille de l'adresse

	Connecte la socket référencée par le descripteur de fichier sockfd à l'adresse indiquée par serv_addr.
	En général, les sockets des protocoles orientés connexion ne réussissent un appel connect() qu'une seule fois, alors qu'une socket d'un
	protocole sans connexion peut appeler connect() plusieurs fois pour changer son affectation

	retour : Renvoie 0 si il réussit.
			 Renvoie -1 en cas d'échec, auquel cas errno est renseignée en conséquence.  


listen:
#include <sys/types.h>
#include <sys/socket.h>
int listen(int sockfd, int backlog);
	- ATTENDRE DES CONNEXIONS SUR UNE SOCKET

	args :
		1. int sockfd : fd qui fait référence à une socket de type SOCK_STREAM ou SOCK_SEQPACKET.
		2. int backlog : longueur maximale jusqu'à laquelle la file des connexions en attente pour sockfd peut croître.
					(si une nouvelle connexion arrive alors que la file est pleine, le client reçoit une erreur
					indiquant ECONNREFUSED, ou, si le protocole sous-jacent supporte les retransmissions, la
					requête peut être ignorée afin qu'un nouvel essai réussisse.)

	listen() marque la socket référencée par sockfd comme une socket passive, c'est-à-dire comme une socket qui sera
	utilisée pour accepter les demandes de connexions entrantes en utilisant accept(2). 
	
	retour : Renvoie 0 si il réussit.
			 Renvoie -1 en cas d'échec, auquel cas errno est renseignée en conséquence.  


accept:
#include <sys/types.h>
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *adresse, socklen_t *longueur);
	- ACCEPTER UNE CONNEXION SUR UNE SOCKET

	args :
		1. int sockfd : fd de la socket  socket qui a été créée en mode connecté (SOCK_STREAM et SOCK_SEQPACKET) avec la fonction socket(2), attachée à une adresse avec bind(2), et attend des connextions après un appel listen(2). 
		2. struct sockaddr *adresse : pointeur sur une structure sockaddr, remplie avec l'adresse du correspondant se connectant
		3. socklen_t *longueur : paramètre-résultat : il doit contenir initialement la taille de la structure pointée par adresse, et est renseigné au retour par la longueur réelle (en octet) de l'adresse remplie. Quand adresse vaut NULL, rien n'est rempli.
	
	extrait la première connexion de la file des connexions en attente de la socket sockfd à l'écoute, crée une nouvelle
	socket connectée, et renvoie un nouveau descripteur de fichier qui fait référence à cette socket.
	La nouvelle socket n'est pas en état d'écoute.
	La socket originale sockfd n'est pas modifiée par l'appel système.
	S'il n'y a pas de connexion en attente dans la file, et si la socket n'est pas marquée comme non bloquante, accept() se
	met en attente d'une connexion.
	Si la socket est non bloquante, et qu'aucune connexion n'est présente dans la file, accept() échoue avec l'erreur EAGAIN.

	Pour être prévenu de l'arrivée d'une connexion sur une socket, on peut utiliser select(2) ou poll(2). Un événement « lecture »
	sera délivré lorsqu'une tentative de connexion aura lieu, et on pourra alors appeler accept() pour la valider.
	Autrement, on peut configurer la socket pour qu'elle envoie un signal SIGIO lorsqu'une activité la concernant se produit
	voir socket(7) pour plus de détails.

	retour : s'il reussit, renvoie le fd de la nouvelle socket
	S'il échoue, renvoie -1 et errno contient le code d'erreur.



htonl,  htons,  ntohl, ntohs :
#include <arpa/inet.h>
- CONVERTIR DES DONNEES ENTRE L'ORDRE DES OCTETS ET DE L'HOTE ET DU RESEAU

unit32_t htonl(uint32_t hostlong);
	convertit hostlong depuis l'ordre des octets de l'hôte vers celui du réseau

uint16_t htons(uint16_t hostshort);
	convertit hostshort depuis l'ordre des octets de l'hôte vers celui du réseau.

uint32_t ntohl(uint32_t netlong);
	convertit netlong depuis l'ordre des octets du réseau vers celui de l'hôte

uint16_t ntohs(uint16_t netshort);
	convertit netshort depuis l'ordre des octets du réseau vers celui de l'hôte.



inet_addr:
<sys/socket.h>
<netinet/in.h>
<arpa/inet.h>
in_addr_t inet_addr(const char *cp);
	- CONVERTIR UNE ADRESSE INTERNET NUMERIQUE POINTEE IPV4 EN UNE DONNEE BINAIRE
	
	args :
		const char *cp : adresse Internet de l'hôte a convertir

	Les éléments d'une adresse en notation pointée peuvent être indiqués sous forme décimale, octale (avec un 0 devant) ou hexadécimale (avec un 0X devant).
	La terminologie des adresses sous ces formes est appelée notation numérique pointée IPV4.
	La forme qui utilise exactement quatre nombres décimaux est appelée notation décimale pointée IPV4 (ou quelques fois : notation quatre points IPv4). 

	retour :
		in_addr_t (equivalent a uint32 (unsigned long)) :  donnée binaire dans l'ordre des octets du réseau.
		Si l'adresse est invalide, INADDR_NONE (généralement -1) est renvoyé.


inet_ntoa:
<sys/socket.h>
<netinet/in.h>
<arpa/inet.h>
char *inet_ntoa(struct in_addr in);
	- CONVERTIR UNE ADRESSE INTERNET BINAIRE EN UNE CHAINE DE CARACTERES NUMERIQUE POINTEE

	args :
		struct in_addr in : adresse Internet de l'hôte a convertir
		struct in_addr {
			in_addr_t s_addr;
		};


send:
<sys/types.h>
<sys/socket.h>
ssize_t send(int s, const void *buf, size_t len, int flags);
	- ENVOYER UN MESSAGE SUR UNE SOCKET

	args :
		1. int s : fd de la socket emettrice
		2. const void *buf : message
		3. size_t len : taille du message
		4. int flags :
		Sans aucun paramètre flags, send() est équivalent à write.

	retour : 
		S'il réussit, l'appel système renvoie le nombre de caractères émis.
		S'il échoue, il renvoient -1 et errno contient le code d'erreur.

		Si le message est trop long pour être transmis intégralement par le protocole sous-jacent, l'erreur EMSGSIZE sera déclenchée et rien ne sera émis. 
		Si la socket ne dispose pas de la place suffisante pour le message, alors send() va bloquer, à moins que la socket ait été configurée en mode d'entrées-sorties non bloquantes auquel cas elle renverra EAGAIN.
		Pour verifier s'il est possible d'émettre des données, on peut utiliser l'appel système select


recv:
<sys/types.h>
<sys/socket.h>
ssize_t recv(int s, void *buf, ssize_t len, int flags);
	- RCECEVOIR UN MESSAGE SUR UNE SOCKET

	args :
		1. int s : fd de la socket qui envoie le message
		2. void *buf : buffer ou est stocke le message
		3. ssize_t len : taille en octet du buffer
		4. int flags : type de reception
	
	retour :
		Si l'appel reussit, renvoie la longueur du message.
		Si aucun message n'est disponible sur la socket, les fonctions de réception se mettent en attente, à moins que la socket soit
		non bloquante (voir fcntl(2)) auquel cas la valeur -1 est renvoyée, et errno est positionnée à EAGAIN ou EWOULDBLOCK.
	
	Pour savoir si  des données supplémentaires sont disponibles dans la socket, on peut utiliser select(2), poll(2), ou epoll(7).


signal:
<signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
	-  GESTION DES SIGNAUX

	args :
		1. int signum : signal a gerer
		2. sighandler_t handler : gestionnaire a installer
			SIG_IGN : ignore
			SIG_DFL : action par defaut du signal
			Adresse d'une fonction

	retour :
		Renvoie la valeur précédente du gestionnaire de signaux, ou SIG_ERR en cas d'erreur.  



lseek:
<sys/types.h>
<unistd.h>
off_t lseek(int fd, off_t offset, int whence);   
	- POSITIONNER LA TETE DE LECTURE/ECRITURE DANS UN FICHIER

	args :
		1. fd : fichier ouvert
		2. off_t offset : position a laquelle placer la tete de lecture
		3. int whence : directive a suivre
			SEEK_SET : La tête est placée à offset octets depuis le début du fichier. 
			SEEK_CUR : La tête de lecture/écriture est avancée de offset octets. 
			SEEK_END : La tête est placée à la fin du fichier plus offset octets. 
	
	retour :
		S'il réussit, renvoie le nouvel emplacement, mesuré en octets depuis le début du fichier.
		En cas d'échec, la valeur (off_t) -1 est renvoyée, et errno contient le code d'erreur.  



fstat:
<sys/types.h>
<sys/stat.h>
<unistd.h>
int fstat(int fd, struct stat *buf);
	- OBTENIR L'ETAT D'UN FICHIER (FILE STATUS)

	- récupère l'état du fichier référencé par fd et remplit le tampon buf
	- pas besoin des droits d'accès au fichier pour obtenir les informations

	args :
		1. fd : fd dont on veut obtenir les informations
		2. struct stat *buf : structure stat remplie par la fonction
		struct stat {
			dev_t     st_dev;         /* périphérique sur lequel le fichier réside */             */
			ino_t     st_ino;         /* Numéro d’inœud                   */
			mode_t    st_mode;        /* Protection                       */
			nlink_t   st_nlink;       /* Nombre de liens physiques        */
			uid_t     st_uid;         /* UID du propriétaire              */
			gid_t     st_gid;         /* GID du propriétaire              */
			dev_t     st_rdev;        /* Type de périphérique             */
			off_t     st_size;        /* Taille totale du fichier en octets */
			blksize_t st_blksize;     /* Taille  de  bloc  « préférée »  pour des entrées-sorties efficaces */
			blkcnt_t  st_blocks;      /* Nombre de blocs de 512 octets alloués au fichier */

			/* Depuis Linux 2.6, le noyau permet une précision à la
			   nanoseconde pour les champs temporels suivants. Pour
			   plus de précisions avant Linux 2.6, consultez les NOTES. */

			struct timespec st_atim;  /* Heure dernier accès              */
			struct timespec st_mtim;  /* Heure dernière modification      */
			struct timespec st_ctim;  /* Heure dernier changement état    */

		#define st_atime st_atim.tv_sec      /* Rétrocompatibilité        */
		#define st_mtime st_mtim.tv_sec
		#define st_ctime st_ctim.tv_sec
		};


	retour :
		S'il  réussit, cet appel système renvoie 0.
		S'il échoue, il renvoie -1 et remplit errno en conséquence.



fcntl:
<unistd.h>
<fcntl.h>
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock *lock);
	- EFFECTUER DES OPERATIONS SUR UN FD

	- permet de se livrer à l'une des opérations décrites plus loin sur le descripteur de fichier fd.
	- l'opération est déterminée par la valeur de l'argument cmd. 

	- args :
		1. fd
		2. cmd : operation a executer sur le fd
		3. (optionnel) La  nécessité  de  fournir  ce  paramètre
		dépend  de  cmd. le paramètre doit être du type indiqué entre parenthèses après chaque nom
		de commande cmd (dans la plupart des cas, le type requis est un int, et le  paramètre  est
		identifié  en  utilisant  le  nom  arg),  ou  void  est  indiqué si le paramètre n'est pas
		nécessaire.
	
	- differentes operations :
		-    Dupliquer un descripteur de fichier
		- Obtenir/modifier les attributs du descripteur de fichier
		-  Obtenir/modifierles attribut d'état du fichier
		- Verrouillages coopératifs
		-   Verrouillage obligatoire
		- Gestion des signaux
		- Gestion des baux
		-  Notification de modification de fichier et de répertoire (dnotify)
		- Changer la capacité d'un tube
	
	- retour : la veleur de retour depend de l'operation



poll (ou équivalent - select(), kqueue(), epoll()):
<poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int délai);
	- ATTENDRE UN EVENEMENT CONCERNANT UN FD

	- attend que l'un des descripteurs de fichier parmi un ensemble soit prêt pour effectuer des entrées-sorties. 
	- si aucun événement attendu (ni aucune erreur) ne s'est déjà produit, poll() bloque jusqu'à ce que l'un des événements survienne.

	- args :
		1. struct pollfd *fds : tableau de structures qui contiennent chacune un fd a surveiller
			struct pollfd {
				int   fd;         /* Descripteur de fichier ouvert */
				short events;     /* Événements attendus, paramètre d'entrée  */
				short revents;    /* Événements détectés, paramètre de sortie    */
								  /* Les bits qui peuvent être positionnés ou renvoyés dans events et revents sont définis dans <poll.h> : */
			};
		2. nfds_t nfds :  unsigned int utilise pour decrire le nombre de fds, en l'occurence, le nombre d'elements dans notre tableau de structures
		3. int delai : L'argument délai définit une limite supérieure, en millisecondes, sur le temps pendant lequel poll() bloquera. Définir une valeur négative pour délai signifie un délai d'attente infini. 
		
	- retour :
		S'ils réussissent, ces appels renvoient une valeur positive représentant le nombre de structures ayant un champ revents non nul, c'est-à-dire le nombre de structures pour lesquels un événement attendu ou une erreur s'est produit.
		Une valeur de retour nulle indique un dépassement du délai d'attente et qu'aucun descripteur de fichier n'était prêt.
		S'ils échouent, ces appels renvoient -1, et errno contient le code d'erreur.  


			##############################################################################################


NOTES 


SOCKET :

	Pour accepter des connexions, les étapes suivantes sont effectuées :

		1.
			Une socket est créée avec socket(2). 
		2.
			La socket est limitée à une adresse locale avec bind(2), ainsi d'autres sockets peuvent y être connect(2)ées. 
		3.
			La volonté d'accepter des connexions entrantes et une limite de file pour les connexions entrantes sont spécifiées avec listen(). 
		4.
			Les connexions sont acceptées avec accept(2). 


	Le protocole IRC (Internet Relay Chat) utilise des sockets pour la communication entre le client et le serveur. Le serveur doit donc
	créer un socket d'écoute qui attend les connexions entrantes des clients et un socket pour chaque connexion acceptée. Chaque socket
	accepté est utilisé pour communiquer avec le client correspondant.


SERVEUR/CLIENT :

	Dans un serveur IRC (Internet Relay Chat) :

	client : l'application logicielle qui est exécutée sur l'ordinateur d'un utilisateur pour se connecter au serveur IRC et participer à
	des conversations de groupe ou privées avec d'autres utilisateurs connectés au même serveur.

	serveur : l'application logicielle qui gère les connexions des clients et permet à ces derniers de communiquer entre eux.
	Il est responsable de l'acheminement des messages des clients aux autres utilisateurs connectés au même canal de discussion.
	Le serveur IRC peut également être configuré pour fournir des fonctionnalités supplémentaires, telles que la gestion des utilisateurs,
	la protection contre les spammeurs, la modération des discussions, etc.

	Concrètement, dans un serveur IRC, le client se connecte au serveur en utilisant un nom d'utilisateur et un mot de passe (si requis).
	Une fois connecté, le client peut rejoindre un ou plusieurs canaux de discussion où il peut interagir avec d'autres utilisateurs. Le client
	peut également envoyer des messages privés à un utilisateur spécifique en utilisant son pseudonyme ou son adresse IP.

	Le serveur IRC, quant à lui, gère les connexions des clients et les canaux de discussion. Il reçoit les messages envoyés par les clients et
	les relaie aux autres utilisateurs connectés au même canal. Le serveur IRC peut également être programmé pour effectuer diverses tâches,
	telles que la gestion des droits d'accès, la surveillance des conversations, la détection des spams, etc.


SOCKET SERVEUR/CLIENT

	La socket créée par le client est différente de celle créée par le serveur lorsqu'il accepte une connexion :

	- socket créée par le client : créée par le client utilisée pour envoyer des messages au serveur
	- socket créée par le serveur : utilisée pour recevoir des messages de l'utilisateur

	Donc, pour résumer, le client crée une socket lorsqu'il se connecte au serveur IRC en utilisant la fonction connect(), et le serveur crée une
	socket lorsqu'il accepte une connexion en utilisant la fonction accept().


LIEN FONCTIONS 

	Lorsqu'un utilisateur souhaite envoyer un message à un autre utilisateur sur un serveur IRC, le processus suivant peut se produire :

		1. Le client IRC de l'utilisateur demande l'etablissement d'une connexion a l'aide de connect().

		2. Le serveur IRC accepte la connexion du client en utilisant la fonction accept(). Cette fonction crée un nouveau socket pour la
		communication entre le client et le serveur.

		3. Le serveur IRC attend la demande de connexion d'un autre utilisateur en écoutant sur le socket créé avec la fonction listen().

		4. Lorsqu'un autre utilisateur se connecte au serveur IRC, le serveur accepte la connexion en utilisant la fonction accept(). Cette
		fonction crée un nouveau socket pour la communication entre l'utilisateur et le serveur.

		5. L'utilisateur envoie un message au serveur IRC en utilisant la fonction send(). Cette fonction envoie le message sur le socket créé
		avec la fonction connect().

		6. Le serveur IRC reçoit le message de l'utilisateur en utilisant la fonction recv(). Cette fonction récupère le message sur le socket
		créé avec la fonction accept().

		7. Le serveur IRC relaie le message à l'utilisateur destinataire en utilisant la fonction send() sur le socket créé avec la fonction accept().

		8. L'utilisateur destinataire reçoit le message en utilisant la fonction recv() sur le socket créé avec la fonction connect().

	En somme, les fonctions socket(), bind(), listen(), connect() et accept() sont utilisées pour établir une connexion entre le client et le serveur IRC,
	créer un socket d'écoute pour attendre les demandes de connexion entrantes, accepter les connexions des clients, recevoir et envoyer des messages entre
	les clients connectés au serveur.



	ce qui se passe quand le client fait /join #help :

<< MODE #help
	>> :server_name 324 <nickname> <#channel> +tncPlj 200 3:10
	--> chanquery mode
<< WHO #help
	>> :server_name 329 <nickname> <#channel> 1111763723

	>> :server_name 352 <client> <#channel> <~username> <host> 							 	<server_name> 		  <nickname> <flags> :<hopcount> <realname>
	>> :server_name 352 ch		  #help		 ~cmeston	45cb-3072-bdd-cd6-2d58.210.62.ip 	server_name 		  ch 	     H 		 :0 		  Chine MESTON
	>> :fus.dal.net 352 ch 		  #help		 ~MS		261b-c219-82d-351c-3ccc.219.104.ip	punch.wa.us.dal.net   Guest41087 G		 :3			  Thank You Whoising Me. May I Help You?
	>> :fus.dal.net 352 ch		  #help		 ~quassel	467.dedi.hostingby.design 			nonstop.ix.me.dal.net AvocetVIS  H		 :3			  nunya
	>> :fus.dal.net 352 ch 		  #help		 ~Marhba	17f8-ae5b-716e-f3cf-407f.158.102.ip	lion.tx.us.dal.net	  KoRniChe	 H		 :3			  Marhba User
	...
	>> :server_name 315 ch #help :End of /WHO list.
<< MODE #help b
	>> :server_name 368 cmeston #help :End of Channel Ban List


329		RPL_CREATIONTIME (329)
			"<client> <channel> <creationtime>"


332		RPL_TOPIC
			"<channel> :<topic>"

352		RPL_WHOREPLY (352)
			"<client> <channel> <username> <host> <server> <nick> <flags> :<hopcount> <realname>"
			<flags> contains the following characters, in this order:
				1. Away status: the letter H ('H', 0x48) to indicate that the user is here, or the letter G ('G', 0x47) to indicate that the user is gone.
				2. Optionally, a literal asterisk character ('*', 0x2A) to indicate that the user is a server operator.
				3. Optionally, the highest channel membership prefix that the client has in <channel>, if the client has one.
				4. Optionally, one or more user mode characters and other arbitrary server-specific flags.


353    RPL_NAMREPLY
              "( "=" / "*" / "@" ) <channel>
               :[ "@" / "+" ] <nick> *( " " [ "@" / "+" ] <nick> )
         - "@" is used for secret channels, "*" for private
           channels, and "=" for others (public channels).

366    RPL_ENDOFNAMES
	          "<channel> :End of NAMES list"

324    RPL_CHANNELMODEIS
              "<channel> <mode> <mode params>"

315    RPL_ENDOFWHO
              "<name> :End of WHO list"

368    RPL_ENDOFBANLIST
              "<channel> :End of channel ban list"

http://abcdrfc.free.fr/rfc-vf/rfc1459.html#422


TO DO LIST :
	- Commande client server
		PASS			-> met un mot de passe de connection
		AUTHENTICATE	-> ???
		NICK			-> change le nickname de l'utilisateur
		USER			-> a la connection, specifie le username, hostname, real name, et mode de base du client
		OPER			-> authentifie un client en tant que operateur (moderateur)
		QUIT			-> se deconnecte
		CAP				-> ???
		PING / PONG		-> verifie la connection (repond PONG)

	- Commande channel
		JOIN	-> rejoins les channels en arguments, les cree s'ils n'existent pas
		PART	-> quitte les channels en arguments
		MODE	-> paramettre le mode du channel (utilisable pour les users)
		TOPIC	-> paramettre le topic du channel
		NAMES	-> liste tous les nicknames des clients (du channel en argument, ou tout le monde si pas d'argument)
		LIST	-> liste tous les channels du server (si une liste de channels en argument, liste les topics)
		INVITE	-> invite un nickname dans un channel (si le channel existe, il faut faire partie du channel pour inviter)
		KICK	-> vire le client (en argument) du channel (en argument) (il faut etre operateur du channel)

	- Commande client / client
		PRIVMSG	-> envoie un message a la target (en argument), qui est un user ou un channel

	- Operateur (client avec des privileges, moderateur)
		KILL	-> deconnecte un autre client de force
		RESTART	-> redemarre le server (risque)


QUIT :
JOIN :	- (une fois le channel rejoint, envoyer a la personne qui join le RPL_TOPICWHOTIME (333))
		- (a faire ou pas ?) argument "0" (/join 0 ?) qui quitte tous les channels dans lequel est le user
MODE :
NICK :
PASS :
PRIVMSG :
KICK :
TOPIC :
NAMES :
OPER :
PART :


COMMANDE PAS DU TOUT FAITE :


TRUC EN PLUS :
	ok !		- voir si on verifie des caracteres interdits dans le nickname
	ok !		- rajouter dans toutes les erreurs le channel ou on veut l'envoyer
	ok !		- bien virer le user de partout quand il part
	ok !		- voir pk les mots sont tronques dans certains message d'erreur (ex : "incorrect", "have not registered"...)
				- rendre plus propre l'enchainement close, -1, erase quand un client part
	ok !		- envoyer mode +o a la cretation d'un channel
	ok !		- manque erreur ERR_NOSUCHNICK pour mode
	ok !		- pb de parsing raison KILL
	ok !		- changer la RPL par defaut (excessive spammig) dans KILL
				- signaux a revoir
	ok !		- si on quit et qu'on fait /server ca marche pas
				- 	Message reçu : MODE #vip_salon navierxiel +o
					Received command MODE
					OK c'est bien un operateur
					changes = +i
						(???)
	ok !		- voir les modes du sujet
	ok !		- topic pour les autorisations
				- si mauvais mot de passe, nick et user ne font rien mais n'ont pas de message d'erreur (cf. nick.cpp:36)
							-> fait mais pas teste !!!
	ok !		- supprimer les channels vides ? (zero utilisateur)
	ok !		- erreur mode +o invalid user
	ok !		- rajouter # dans join si existe deja
	ok !		- si on fait names, ca nous rajoute dans la liste a droite
				- nick : si on tente de changer de nick pour un nick invalide, on change de nick pour le suivant dans notre liste possible
								--> en regardant notre code, je suis pas sure que ce soit notre faute ?
								--> si tu ne comprends pas ce que je veux dire :
								--> fait un user avec le nick "a", le 2e nick "b" et le 3e nick "c"
								--> puis essaye de lui faire la commande "/nick #bla" (qui est un nickname invalide)
								--> on va lui changer son nick pour "b" du coup...
								--> et c'est pareil si on veut le changer par un nick deja pris
	ok !		- rpl d'erreur si commande inconnu
	ok !		-  :Nickname is already in use. Retrying with #tutu2...
	ok !		- verifier mdp main ""




